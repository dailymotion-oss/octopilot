---
title: "Commits"
anchor: "commit"
weight: 50
---

After running all the [updaters](#updaters), octopilot will commit the changes on each [repository](#repos). You can control which files will be committed, and how the commit will be created, using the Octopilot's CLI flags.

## Git clone

Flags related to the `git clone` operation:

- `--git-clone-dir` (string): optional path to a directory used to clone the git repositories. Default to a newly created directory in the system temporary directory (defined by the `TMPDIR` environment variable, defaulting to `/tmp`). Note that by default all files created inside this directory will be deleted at the end of the process, unless the `--keep-files` flag is set.

- `--git-recurse-submodules` (bool): recursively initialize all submodules. Disabled by default.

## Git index/stage

By default, all files changed by the [updaters](#updaters) will be added to the git "index" - so that they can be added to the git commit. This is configurable through the following flags:

- `--git-stage-all-changed` (boolean): if set to `true` (the default), then all changed files will be "staged" - or added to the git index. Set it to `false` to control which files should be staged.
- `--git-stage-pattern` (array of string): list of path patterns that will be "staged" - or added to the git index.

For example, to make sure you will only commit the changes to the `helmfile.yaml` file:

```bash
$ octopilot \
    --git-stage-all-changed=false \
    --git-stage-pattern=helmfile.yaml \
    ...
```

## Git commit

Although there are good default values, you can configure how Octopilot will create the git commit:

- `git-author-name` (string): the name of the author of the git commit. Default to the value of the `GIT_AUTHOR_NAME` environment variable, or if unset, the `user.name` git config value.
- `git-author-email` (string): the email of the author of the git commit. Default to the value of the `GIT_AUTHOR_EMAIL` environment variable, or if unset, the `user.email` git config value.
- `git-committer-name` (string): the name of the committer. Default to the value of the `GIT_COMMITTER_NAME` environment variable, or if unset, the `user.name` git config value.
- `git-committer-email` (string): the email of the committer. Default to the value of the `GIT_COMMITTER_EMAIL` environment variable, or if unset, the `user.email` git config value.
- `git-commit-title` (string): the title of the commit. Note that you can use the [templating](#templating) feature here.
- `git-commit-body` (string): the body of the commit. Note that you can use the [templating](#templating) feature here.
- `git-commit-footer` (string): the footer of the commit. Default to Octopilot's signature, to indicate that this commit was generated by a tool.

The commit message is composed of the commit title, body and optional footer:

```go-text-template
${git-commit-title}

${git-commit-body}

-- 
${git-commit-footer}
```

For example, to update the version of an application named `my-app`, and write a nice commit message:

```bash
$ octopilot \
    --repo "my-org/my-gitops-repo" \
    --update "yaml(file=my-app/config.yaml,path='version')=${VERSION}" \
    --git-commit-title 'chore(deps): update my-app to {{ env "VERSION" }}' \
    --git-commit-body '{{ githubRelease (print "my-org/my-app-repo/" (env "VERSION")) | md2txt }}' \
    ...
```

It's using the [templating](#templating) feature to retrieve the GitHub Release for your application's version, and convert it to raw text. So in your commit message, you'll see what changed in the new version.

## Git push

- `git-branch-prefix` (string): when pushing the changes to the "origin" git repository, a new branch with a random name will be created. You can control the prefix of this random name, which default to `octopilot-`.

Note that Octopilot requires permissions to push on the GitHub repositories to update. For the moment, it doesn't support forking the repository, and creating the Pull Request from the fork.

## Git signing

- `git-signing-key-path` (string): when provided, Octopilot will use the GPG private key file to sign commits or tags, which will allow GitHub to verify the committer's identity. See [Add a GPG key](https://docs.github.com/en/authentication/managing-commit-signature-verification/adding-a-gpg-key-to-your-github-account).
- `git-signing-key-passphrase` (string): Passphrase to decrypt the GPG private key used to sign commits. Leave empty if the private key is stored unencrypted.
