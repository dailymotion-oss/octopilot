<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.84.0"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>Octopilot - Octopilot</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=favicon.png><link rel=stylesheet href=css/style.893557bc36f9dfda17c26bcf9db87c3f52ed314bc1fc66448453774f79f6ab02.css></head><body class="page page-default-single"><div class=wrapper><div class=header><div class=container><div class=logo><a href=/>Octopilot</a></div><div id=main-menu class=main-menu><ul><li class=menu-item-><a href=https://github.com/dailymotion-oss/octopilot><span>GitHub</span></a></li><li class=menu-item-><a href=https://github.com/dailymotion-oss><span>Dailymotion</span></a></li></ul></div><button id=toggle-main-menu-mobile class="hamburger hamburger--slider" type=button>
<span class=hamburger-box><span class=hamburger-inner></span></span></button></div></div><div class="container pt-2 pt-md-6 pb-3 pb-md-6"><div class=row><div class="col-12 col-md-3 mb-3"><div class=sidebar><div class=docs-menu><div class=navigation><nav class=internal><ul><li><a href=#intro>Introduction</a></li><li><a href=#usage>Usage</a></li><li><a href=#repos>Repositories</a><ul><li><a href=#static>Static list</a></li><li><a href=#dynamic>Dynamic list</a></li><li><a href=#commit>Commits</a></li><li><a href=#pull-request>Pull Requests</a></li></ul></li><li><a href=#updaters>Updaters</a><ul><li><a href=#yaml>YAML</a></li><li><a href=#yq>YQ</a></li><li><a href=#helm>Helm</a></li><li><a href=#sops>Sops</a></li><li><a href=#regex>Regex</a></li><li><a href=#exec>Exec</a></li><li><a href=#value>Value</a></li></ul></li><li><a href=#github-auth>GitHub Auth</a></li><li><a href=#advanced>Advanced</a><ul><li><a href=#templating>Templating</a></li></ul></li><li><a href=#use-cases>Use cases</a><ul><li><a href=#use-case-app-promotion>Promoting a new application release</a></li><li><a href=#use-case-lib-promotion>Promoting a new library release</a></li><li><a href=#use-case-update-certs>Updating certificates</a></li><li><a href=#use-case-go-deps>Updating Go dependencies</a></li><li><a href=#use-case-preview>Previsualizing changes</a></li><li><a href=#detecting-errors-in-scripts>Detecting errors in scripts</a></li><li><a href=#handle-maximum-number-of-repositories-in-parallel>Handle maximum number of repositories in parallel</a></li></ul></li></ul></nav><nav class=external><div class=external-title></div><ul id=shortcuts><li><a href=https://github.com/dailymotion-oss/octopilot target=_blank rel=noopener>Source Code</a></li></ul></nav></div><div class=version>v1.12.19 released on Jan 24, 2025</div></div></div></div><div class="col-12 col-md-9"><h1 class=title>Documentation for Octopilot v1.12.19</h1><h2>Released on Jan 24, 2025</h2><div class=content><section class=changelog><div class=content><p>This is the full 1-page documentation for <a href=https://github.com/dailymotion-oss/octopilot/releases/tag/v1.12.19>Octopilot v1.12.19</a>.</p><h2 id=changelog>Changelog</h2><h3 id=chore>Chore</h3><ul><li><strong>deps:</strong> bump github.com/rs/xid from 1.5.0 to 1.6.0</li></ul></div></section><section id=intro><h1><a href=#intro>Introduction</a></h1><div class=content><p><strong>Octopilot</strong> is a CLI tool designed to help you automate your Gitops workflow, by automatically creating and merging GitHub Pull Requests to update specific content in Git repositories.</p><p>If you are doing Gitops with GitHub-hosted repositories, <strong>Octopilot</strong> is your <em>swiss army knife</em> to propagate changes in your infrastructure.</p><p><strong>Octopilot</strong> was initially developed at <a href=https://www.dailymotion.com/>Dailymotion</a>, and is a core component of our Gitops workflow - you can read our blog post <a href=https://vbehar.medium.com/introducing-octopilot-a-cli-to-automate-the-creation-of-github-pull-request-in-your-gitops-e49b9eb0177a>Introducing Octopilot: a CLI to automate the creation of GitHub pull requests in your gitops workflow</a>.</p><p>It works by:</p><ul><li>cloning one or more <a href=#repos>repositories</a>, defined either:<ul><li><a href=#static>statically</a></li><li><a href=#dynamic>dynamically</a>, using environment variables or GitHub search queries</li></ul></li><li>running one or more <a href=#updaters>updaters</a> on each cloned repository, using either:<ul><li>the <a href=#yaml>YAML updater</a>, to quickly update YAML files</li><li>the <a href=#yq>YQ updater</a>, based on <a href=https://github.com/mikefarah/yq>mikefarah&rsquo;s yq</a>, to manipulate YAML or JSON files as you want</li><li>the <a href=#helm>Helm updater</a>, to easily update the dependencies of an <a href=https://helm.sh/>Helm</a> chart</li><li>The <a href=#sops>sops updater</a>, to manipulate files encrypted with <a href=https://github.com/mozilla/sops>mozilla&rsquo;s sops</a></li><li>The <a href=#regex>regex updater</a>, to update any kind of text file using a regular expression</li><li>The <a href=#exec>exec updater</a>, to execute any command you want</li></ul></li><li><a href=#commit>commit/push</a> the changes</li><li>create <a href=#pull-request>Pull Requests</a> and optionally merge them</li></ul><p>If you want to see what you can do with Octopilot for real, here is a set of real-world <a href=#use-cases>use-cases</a> that we have at <a href=https://www.dailymotion.com/>Dailymotion</a>:</p><ul><li><a href=#use-case-app-promotion>Promoting a new application release</a> with a gitops workflow</li><li><a href=#use-case-lib-promotion>Promoting a new library release</a> to a dynamic list of application repositories</li><li><a href=#use-case-update-certs>Updating certificates</a> with a gitops workflow</li><li><a href=#use-case-go-deps>Updating Go dependencies</a></li><li><a href=#use-case-preview>Previsualizing changes</a> done by octopilot, without pushing to the remote GitHub repository</li></ul></div></section><section id=usage><h1><a href=#usage>Usage</a></h1><div class=content><p>You can download the binary or see the <code>docker pull</code> commands from the <a href=https://github.com/dailymotion-oss/octopilot/releases/latest>release page on GitHub</a>.</p><p>There are no dependencies - not even on <code>git</code>.</p><p>There are no configuration files - we use CLI flags for everything. You can run <code>octopilot -h</code> to see all the flags. Some of them can be used multiple times, such as the <code>--repo</code> or <code>--update</code> flags.</p><p>You will need a GitHub token or app to authenticate with GitHub. See the <a href=#github-auth>GitHub Auth</a> section for more details.</p><p>Here is an example of using Octopilot to update multiple repositories, using multiple updaters:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --github-token <span class=s2>&#34;my-github-token&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;my-org/some-repo&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;my-org/another-repo(merge=true)&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(env=PROMOTE_TO_REPOSITORIES)&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(query=org:my-org topic:my-topic)&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(searchtype=code,query=org:my-org filename:my-file path:dir-path in-file-text)&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(searchtype=code,query=org:my-org filename:my-file path:dir-path fork:true)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yaml(file=config.yaml,path=&#39;version&#39;)=file(path=VERSION)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yq(file=helmfile.yaml,expression=&#39;(.releases[] | select(.chart == \&#34;repo/my-chart\&#34;) | .version ) = strenv(VERSION)&#39;)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;sops(file=secrets.yaml,key=path.to.base64encodedCertificateKey)=</span><span class=k>$(</span>kubectl -n cert-manager get secrets tls-myapp -o <span class=nv>template</span><span class=o>=</span><span class=s1>&#39;{{index .data \&#34;tls.key\&#34;}}&#39;</span><span class=k>)</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-title <span class=s2>&#34;Updating some files&#34;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><h2 id=continuous-delivery-pipelines>Continuous Delivery Pipelines</h2><p>Octopilot has been designed to be used in a Continuous Delivery pipeline: no dependencies, no configuration file, only 1 command to update multiple repositories&mldr;</p><p>You can use it with <a href=https://www.jenkins.io/>Jenkins</a>, <a href=https://jenkins-x.io/>Jenkins X</a>, <a href=https://tekton.dev/>Tekton</a>, <a href=https://github.com/features/actions>GitHub Actions</a>, &mldr;</p><p>At Dailymotion, we&rsquo;re using it through <a href=https://jenkins-x.io/>Jenkins X</a>/<a href=https://tekton.dev/>Tekton</a> pipelines, and also a few <a href=https://www.jenkins.io/>Jenkins</a> pipelines.</p></div></section><section id=repos><h1><a href=#repos>Repositories</a></h1><div class=content><p>Octopilot operates on GitHub repositories. A single execution of Octopilot can update one or more repositories. There are 2 ways to define the repositories to update:</p><ul><li>using a <a href=#static>static list</a></li><li>using a <a href=#dynamic>dynamic list</a></li></ul></div></section><section id=static><h1><a href=#static>Static list</a></h1><div class=content><p>It is the easiest: just specify the repositories on the CLI using the <code>--repo</code> flag, such as:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;my-github-org/my-first-repo&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;my-github-org/my-second-repo(merge=true)&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;my-github-org/my-third-repo(draft=true,merge=false,branch=dev)&#34;</span>
</code></pre></div><p>You can add as much repositories as you want, each with different configuration.</p><p>It supports the following parameters:</p><ul><li><code>merge</code> (boolean): if <code>true</code>, then the PR created on this repository will be automatically merged - see the <a href=#pull-request>Pull Requests</a> section for more details. It overrides the value of the <code>--pr-merge</code> flag for this specific repository.</li><li><code>mergeauto</code> (boolean): if <code>true</code>, then the PR will merged by Github&rsquo;s auto-merge PR feature. See the <a href=#pull-request>Pull Requests</a> section for more details. It overrides the value of the <code>--pr-merge-auto</code> flag for this specific repository.</li><li><code>mergeautowait</code> (boolean): if <code>true</code>, then wait until the PR is actually merged. See the <a href=#pull-request>Pull Requests</a> section for more details. It overrides the value of the <code>--pr-merge-auto-wait</code> flag for this specific repository.</li><li><code>draft</code> (boolean): if <code>true</code>, then the PR will be created as a <a href=https://github.blog/2019-02-14-introducing-draft-pull-requests/>draft PR</a> on GitHub. You will need to manually mark it as &ldquo;ready for review&rdquo; before being able to merge it. It overrides the value of the <code>--pr-draft</code> flag for this specific repository.</li><li><code>branch</code> (string): the name of the base branch to use when cloning the repository. Default to the <code>HEAD</code> branch - which means the default branch configured in GitHub: usually <code>main</code> or <code>master</code>.</li></ul></div></section><section id=dynamic><h1><a href=#dynamic>Dynamic list</a></h1><div class=content><p>Octopilot can also be used with a &ldquo;dynamic&rdquo; list of repositories: repositories that are unknown when you write the command arguments.</p><p>It can retrieve the list of repositories to update from:</p><ul><li>one or more <strong>environment variables</strong></li><li>one or more <a href=https://docs.github.com/en/github/searching-for-information-on-github/searching-on-github/searching-for-repositories>GitHub Repositories Search Query</a></li><li>one or more <a href=https://docs.github.com/en/search-github/searching-on-github/searching-code>GitHub Code Search Query</a></li></ul><h2 id=using-environment-variables>Using environment variables</h2><p>At runtime, Octopilot will read the list of repositories defined in one or more environment variables, such as:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>export</span> <span class=nv>PROMOTE_TO_REPOSITORIES</span><span class=o>=</span><span class=s2>&#34;my-github-org/my-first-repo my-github-org/my-second-repo(draft=true,merge=false)&#34;</span>
$ <span class=nb>export</span> <span class=nv>ANOTHER_SET_OF_REPOSITORIES</span><span class=o>=</span><span class=s2>&#34;some-org/some-repo;another-org/another-repo(draft=false)&#34;</span>
$ octopilot <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(env=PROMOTE_TO_REPOSITORIES)&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(env=ANOTHER_SET_OF_REPOSITORIES,sep=;,draft=true)&#34;</span>
</code></pre></div><p>It supports the following parameters:</p><ul><li><code>env</code> (string): the name of the environment variable to use, to retrieve the list of repositories.</li><li><code>sep</code> (string): the separator between each repository, default to <code>" "</code> (space).</li><li><code>merge</code> (boolean): if <code>true</code>, then the PRs created on the repositories from this env var will be automatically merged - see the <a href=#pull-request>Pull Requests</a> section for more details. It overrides the value of the <code>--pr-merge</code> flag for the repositories defined in this env var.</li><li><code>mergeauto</code> (boolean): if <code>true</code>, then the PR will merged by Github&rsquo;s auto-merge PR feature. See the <a href=#pull-request>Pull Requests</a> section for more details. It overrides the value of the <code>--pr-merge-auto</code> flag for these specific repository.</li><li><code>mergeautowait</code> (boolean): if <code>true</code>, then wait until the PR is actually merged. See the <a href=#pull-request>Pull Requests</a> section for more details. It overrides the value of the <code>--pr-merge-auto-wait</code> flag for these specific repository.</li><li><code>draft</code> (boolean): if <code>true</code>, then the PRs will be created as <a href=https://github.blog/2019-02-14-introducing-draft-pull-requests/>draft PRs</a> on GitHub. You will need to manually mark them as &ldquo;ready for review&rdquo; before being able to merge them. It overrides the value of the <code>--pr-draft</code> flag for the repositories defined in this env var.</li><li><code>branch</code> (string): the name of the base branch to use when cloning the repositories. Default to the <code>HEAD</code> branch - which means the default branch configured in GitHub: usually <code>main</code> or <code>master</code>.</li></ul><p>Note that each repository listed in an environment variable supports all the parameters defined in the <a href=#static>static definition of a repository</a>.</p><h2 id=using-github-search-query>Using GitHub Search Query</h2><p>A more powerful feature is the ability to load a list of repositories from a <a href=https://docs.github.com/en/github/searching-for-information-on-github/searching-on-github/searching-for-repositories>GitHub Repositories Search Query</a> or a <a href=https://docs.github.com/en/search-github/searching-on-github/searching-code>GitHub Code Search Query</a>, such as:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(query=org:my-github-org topic:some-topic)&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(query=org:my-github-org in:readme some-specific-content-in-the-readme,draft=true)&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(query=org:my-github-org language:java is:private mirror:false archived:false,merge=true)&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(searchtype=code,query=org:my-org filename:my-file path:dir-path in-file-text)&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(searchtype=code,query=org:my-org filename:my-file path:dir-path fork:true)&#34;</span>
</code></pre></div><p>At runtime, Octopilot will use the GitHub API to retrieve the list of repositories matching a given query. This is useful when you have a common library used/imported by many repositories, and you want to create a PR to update the version when there is a new release of your lib. Instead of hardcoding the list of &ldquo;dependant&rdquo; repositories in your library repository, you can use a GitHub Search Query to find all repositories with a specific topic, or specific content in the description of the repo, or specific content in the README.md file of the repo, and so on. So &ldquo;dependant&rdquo; repositories can easily opt-in to get automatic PRs just by adding a topic for example.</p><p>It supports the following parameters:</p><ul><li><code>searchtype</code> (string): represents the type of github search to be performed. Only <code>code</code> and <code>repositories</code> are availables. Default to <code>repositories</code>.</li><li><code>query</code> (string): Specifies search criteria for listing repositories, including filters for file contents, location, language, topic, and more.</li><li><code>merge</code> (boolean): if <code>true</code>, then the PRs created on the repositories from this query will be automatically merged - see the <a href=#pull-request>Pull Requests</a> section for more details. It overrides the value of the <code>--pr-merge</code> flag for the repositories retrieved from this query.</li><li><code>mergeauto</code> (boolean): if <code>true</code>, then the PR will merged by Github&rsquo;s auto-merge PR feature. See the <a href=#pull-request>Pull Requests</a> section for more details. It overrides the value of the <code>--pr-merge-auto</code> flag for these specific repository.</li><li><code>mergeautowait</code> (boolean): if <code>true</code>, then wait until the PR is actually merged. See the <a href=#pull-request>Pull Requests</a> section for more details. It overrides the value of the <code>--pr-merge-auto-wait</code> flag for these specific repository.</li><li><code>draft</code> (boolean): if <code>true</code>, then the PRs will be created as <a href=https://github.blog/2019-02-14-introducing-draft-pull-requests/>draft PRs</a> on GitHub. You will need to manually mark them as &ldquo;ready for review&rdquo; before being able to merge them. It overrides the value of the <code>--pr-draft</code> flag for the repositories retrieved from this query.</li><li><code>branch</code> (string): the name of the base branch to use when cloning the repositories. Default to the <code>HEAD</code> branch - which means the default branch configured in GitHub: usually <code>main</code> or <code>master</code>.</li></ul><p>See the <a href=#use-case-lib-promotion>&ldquo;promoting a new library release&rdquo; use-case</a> for a real-life example of what you can do with this feature.</p></div></section><section id=commit><h1><a href=#commit>Commits</a></h1><div class=content><p>After running all the <a href=#updaters>updaters</a>, octopilot will commit the changes on each <a href=#repos>repository</a>. You can control which files will be committed, and how the commit will be created, using the Octopilot&rsquo;s CLI flags.</p><h2 id=git-clone>Git clone</h2><p>Flags related to the <code>git clone</code> operation:</p><ul><li><p><code>--git-clone-dir</code> (string): optional path to a directory used to clone the git repositories. Default to a newly created directory in the system temporary directory (defined by the <code>TMPDIR</code> environment variable, defaulting to <code>/tmp</code>). Note that by default all files created inside this directory will be deleted at the end of the process, unless the <code>--keep-files</code> flag is set.</p></li><li><p><code>--git-recurse-submodules</code> (bool): recursively initialize all submodules. Disabled by default.</p></li></ul><h2 id=git-indexstage>Git index/stage</h2><p>By default, all files changed by the <a href=#updaters>updaters</a> will be added to the git &ldquo;index&rdquo; - so that they can be added to the git commit. This is configurable through the following flags:</p><ul><li><code>--git-stage-all-changed</code> (boolean): if set to <code>true</code> (the default), then all changed files will be &ldquo;staged&rdquo; - or added to the git index. Set it to <code>false</code> to control which files should be staged.</li><li><code>--git-stage-pattern</code> (array of string): list of path patterns that will be &ldquo;staged&rdquo; - or added to the git index.</li></ul><p>For example, to make sure you will only commit the changes to the <code>helmfile.yaml</code> file:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --git-stage-all-changed<span class=o>=</span><span class=nb>false</span> <span class=se>\
</span><span class=se></span>    --git-stage-pattern<span class=o>=</span>helmfile.yaml <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><h2 id=git-commit>Git commit</h2><p>Although there are good default values, you can configure how Octopilot will create the git commit:</p><ul><li><code>git-author-name</code> (string): the name of the author of the git commit. Default to the value of the <code>GIT_AUTHOR_NAME</code> environment variable, or if unset, the <code>user.name</code> git config value.</li><li><code>git-author-email</code> (string): the email of the author of the git commit. Default to the value of the <code>GIT_AUTHOR_EMAIL</code> environment variable, or if unset, the <code>user.email</code> git config value.</li><li><code>git-committer-name</code> (string): the name of the committer. Default to the value of the <code>GIT_COMMITTER_NAME</code> environment variable, or if unset, the <code>user.name</code> git config value.</li><li><code>git-committer-email</code> (string): the email of the committer. Default to the value of the <code>GIT_COMMITTER_EMAIL</code> environment variable, or if unset, the <code>user.email</code> git config value.</li><li><code>git-commit-title</code> (string): the title of the commit. Note that you can use the <a href=#templating>templating</a> feature here.</li><li><code>git-commit-body</code> (string): the body of the commit. Note that you can use the <a href=#templating>templating</a> feature here.</li><li><code>git-commit-footer</code> (string): the footer of the commit. Default to Octopilot&rsquo;s signature, to indicate that this commit was generated by a tool.</li></ul><p>The commit message is composed of the commit title, body and optional footer:</p><div class=highlight><pre class=chroma><code class=language-go-text-template data-lang=go-text-template><span class=x>${git-commit-title}
</span><span class=x>
</span><span class=x>${git-commit-body}
</span><span class=x>
</span><span class=x>-- 
</span><span class=x>${git-commit-footer}
</span></code></pre></div><p>For example, to update the version of an application named <code>my-app</code>, and write a nice commit message:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;my-org/my-gitops-repo&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yaml(file=my-app/config.yaml,path=&#39;version&#39;)=</span><span class=si>${</span><span class=nv>VERSION</span><span class=si>}</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    --git-commit-title <span class=s1>&#39;chore(deps): update my-app to {{ env &#34;VERSION&#34; }}&#39;</span> <span class=se>\
</span><span class=se></span>    --git-commit-body <span class=s1>&#39;{{ githubRelease (print &#34;my-org/my-app-repo/&#34; (env &#34;VERSION&#34;)) | md2txt }}&#39;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><p>It&rsquo;s using the <a href=#templating>templating</a> feature to retrieve the GitHub Release for your application&rsquo;s version, and convert it to raw text. So in your commit message, you&rsquo;ll see what changed in the new version.</p><h2 id=git-push>Git push</h2><ul><li><code>git-branch-prefix</code> (string): when pushing the changes to the &ldquo;origin&rdquo; git repository, a new branch with a random name will be created. You can control the prefix of this random name, which default to <code>octopilot-</code>.</li></ul><p>Note that Octopilot requires permissions to push on the GitHub repositories to update. For the moment, it doesn&rsquo;t support forking the repository, and creating the Pull Request from the fork.</p><h2 id=git-signing>Git signing</h2><ul><li><code>git-signing-key-path</code> (string): when provided, Octopilot will use the GPG private key file to sign commits or tags, which will allow GitHub to verify the committer&rsquo;s identity. See <a href=https://docs.github.com/en/authentication/managing-commit-signature-verification/adding-a-gpg-key-to-your-github-account>Add a GPG key</a>.</li><li><code>git-signing-key-passphrase</code> (string): Passphrase to decrypt the GPG private key used to sign commits. Leave empty if the private key is stored unencrypted.</li></ul></div></section><section id=pull-request><h1><a href=#pull-request>Pull Requests</a></h1><div class=content><p>After running all the <a href=#updaters>updaters</a> and creating a <a href=#commit>git commit</a>, octopilot will create a Pull Request for each <a href=#repos>repository</a>.</p><h2 id=strategies>Strategies</h2><p>Octopilot has 3 strategies for creating a Pull Request:</p><ul><li><strong>reset</strong> (the default): reset any existing Pull Request from the base branch</li><li><strong>append</strong>: append new commits to any existing Pull Request</li><li><strong>recreate</strong>: always create a new Pull Request</li></ul><p>You can control which strategy to use using the <code>--strategy</code> CLI flag.</p><h3 id=reset-strategy>Reset Strategy</h3><p>This is the default strategy. With this strategy, Octopilot will reset any existing Pull Request from the base branch.</p><p>In detail, it will:</p><ul><li>clone the git repository</li><li>find a &ldquo;matching&rdquo; Pull Request - based on the pre-configured labels. If there is a matching Pull Request, it will use the PR&rsquo;s branch. Otherwise, it will just create a new branch</li><li>reset the branch to the base branch - usually <code>main</code> or <code>master</code></li><li>run the <a href=#updaters>updaters</a></li><li><a href=#commit>commit</a> the changes and (force) push the commit</li><li>update the existing Pull Request title/body/labels/comments/assignees or create a new one</li></ul><p>Note that you can control how the existing Pull Request will be updated. For both the title and body, you can either:</p><ul><li><strong>ignore</strong> the new changes. The existing PR won&rsquo;t be changed - except for the labels, comments, assignees, and of course the commit.</li><li><strong>replace</strong> the title and/or body with the new ones. This is the default for the <strong>reset</strong> strategy.</li><li><strong>prepend</strong> the title and/or body with the new ones. This is mostly useful for the body.</li><li><strong>append</strong> the title and/or body with the new ones. This is mostly useful for the body.</li></ul><h3 id=append-strategy>Append Strategy</h3><p>With this strategy, Octopilot will append new commits to any existing Pull Request.</p><p>In detail, it will:</p><ul><li>clone the git repository</li><li>find a &ldquo;matching&rdquo; Pull Request - based on the pre-configured labels. If there is a matching Pull Request, it will switch to the PR&rsquo;s branch. Otherwise it will just create a new branch from the base branch, and switch to it.</li><li>run the <a href=#updaters>updaters</a></li><li><a href=#commit>commit</a> the changes and push the commit</li><li>update the existing Pull Request title/body/labels/comments/asignees or create a new one</li></ul><p>Note that you can control how the existing Pull Request will be updated. For both the title and body, you can either:</p><ul><li><strong>ignore</strong> the new changes. The existing PR won&rsquo;t be changed - except for the labels, comments, assignees, and of course the commit. This is the default for the <strong>append</strong> strategy.</li><li><strong>replace</strong> the title and/or body with the new ones.</li><li><strong>prepend</strong> the title and/or body with the new ones. This is mostly useful for the body.</li><li><strong>append</strong> the title and/or body with the new ones. This is mostly useful for the body.</li></ul><h3 id=recreate-strategy>Recreate Strategy</h3><p>With this strategy, Octopilot will always create a new Pull Request.</p><p>In detail, it will:</p><ul><li>clone the git repository</li><li>create a new branch from the base branch, and switch to it</li><li>run the <a href=#updaters>updaters</a></li><li><a href=#commit>commit</a> the changes and push the commit</li><li>create a new Pull Request</li></ul><h2 id=creating--updating-pull-requests>Creating / updating Pull Requests</h2><p>You can control how the Pull Requests will be created or updated using the following CLI flags:</p><ul><li><code>--strategy</code> (string): strategy to use when creating/updating the Pull Requests: either <code>reset</code> (reset any existing PR from the current base branch), <code>append</code> (append new commit to any existing PR) or <code>recreate</code> (always create a new PR). Default to <code>reset</code>.</li><li><code>--dry-run</code> (bool): if enabled, won&rsquo;t perform any operation on the remote git repository or on GitHub: all operations will be done in the local cloned repository. So no Pull Request will be created/updated. Default to <code>false</code>.</li><li><code>--pr-title</code> (string): the title of the Pull Request. Default to the commit title. Note that you can use the <a href=#templating>templating</a> feature here.</li><li><code>--pr-title-update-operation</code> (string): the type of operation when updating a Pull Request&rsquo;s title: either <code>ignore</code> (keep old value), <code>replace</code>, <code>prepend</code> or <code>append</code>. Default is: <code>ignore</code> for &ldquo;append&rdquo; strategy, <code>replace</code> for &ldquo;reset&rdquo; strategy, and not applicable for &ldquo;recreate&rdquo; strategy.</li><li><code>--pr-body</code> (string): the body of the Pull Request. Default to the commit body and the commit footer. Note that you can use the <a href=#templating>templating</a> feature here.</li><li><code>--pr-body-update-operation</code> (string): the type of operation when updating a Pull Request&rsquo;s body: either <code>ignore</code> (keep old value), <code>replace</code>, <code>prepend</code> or <code>append</code>. Default is: <code>ignore</code> for &ldquo;append&rdquo; strategy, <code>replace</code> for &ldquo;reset&rdquo; strategy, and not applicable for &ldquo;recreate&rdquo; strategy.</li><li><code>--pr-comment</code> (array of string): optional list of comments to add to the Pull Request.</li><li><code>--pr-assignees</code> (array of string): optional list of assignees (Github usernames) to add to the Pull Request.</li><li><code>--pr-reviewers</code> (array of string): optional list of reviewers (Github usernames) for the Pull Request.</li><li><code>--pr-team-reviewers</code> (array of string): optional list of team reviewers (Github team names) for the Pull Request.</li><li><code>--pr-labels</code> (array of string): optional list of labels to set on the pull requests, and used to find existing pull requests to update. Default to <code>["octopilot-update"]</code>.</li><li><code>--pr-base-branch</code> (string): name of the branch used as a base when creating pull requests. Default to <code>master</code>.</li><li><code>--pr-draft</code> (bool): if enabled, the Pull Request will be created as a draft - instead of regular ones. It means that the PRs can&rsquo;t be merged until marked as &ldquo;ready for review&rdquo;. Default to <code>false</code>.</li></ul><h2 id=merging-pull-requests>Merging Pull Requests</h2><p>Optionally, Octopilot can also automatically merge the Pull Requests it creates. Before merging a Pull Request, Octopilot will wait for the PR to be in a &ldquo;mergable&rdquo; state, and for all required status checks to pass.</p><ul><li><code>--pr-merge</code> (bool): if enabled, the Pull Requests will be automatically merged. It will wait until the PRs are &ldquo;mergeable&rdquo; before merging them. Default to <code>false</code>.</li></ul><p>All the following flags only apply if <code>--pr-merge</code> is enabled.</p><ul><li><code>--pr-merge-auto</code> (bool): merge PRs using Github&rsquo;s <a href=https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/automatically-merging-a-pull-request>auto-merge PR feature</a>.
By default, this will not wait until the PR is merged.
Note, this must also be enabled at the <a href=https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-auto-merge-for-pull-requests-in-your-repository>repository level</a> for it to work. This is a one-time task and <code>ocotopilot</code> will <em>not</em> do this for you. One way of doing this in bulk is using the <code>gh</code> CLI: <code>gh search repos --json url --jq '.[].url' ... | xargs -L1 gh repo edit --enable-auto-merge</code>.</li><li><code>--pr-merge-auto-wait</code> (bool): when <code>--pr-merge-auto</code> is enabled, wait for the PR to be merged by Github.</li><li><code>--pr-merge-method</code> (string): the merge method to use. Either <code>merge</code>, <code>squash</code>, or <code>rebase</code>. Default to <code>merge</code>.</li><li><code>--pr-merge-commit-title</code> (string): optional title of the merge commit.</li><li><code>--pr-merge-commit-message</code> (string): optional body of the merge commit.</li><li><code>--pr-merge-sha</code> (string): optional SHA that pull request head must match to allow merge.</li><li><code>--pr-merge-poll-timeout</code> (string/duration): maximum duration to wait for a Pull Request to be mergeable/merged, using the <a href=https://golang.org/pkg/time/#ParseDuration>Golang syntax</a>. Default to <code>10m</code> (10 minutes).</li><li><code>--pr-merge-poll-interval</code> (string/duration): duration to wait for between each GitHub API call to check if a PR is mergeable/merged, using the <a href=https://golang.org/pkg/time/#ParseDuration>Golang syntax</a>. Default to <code>30s</code> (30 seconds).</li><li><code>--pr-merge-retry-count</code> (int): number of times to retry the merge operation in case of merge failure. Default to <code>3</code>.</li><li><code>--pr-merge-branch-protection</code> (string): One of <code>statusChecks</code>, <code>all</code>, <code>bypass</code>. Wait for the specified kind of branch protection rules to be satisfied before attempting to merge.<ul><li><code>statusChecks</code> waits only for status checks to be passing. This is the default.</li><li><code>all</code> waits for every rule (approvals, commit signature, etc).</li><li><code>bypass</code> will bypass branch protection rules when possible (i.e. the authenticated user/app have permissions to do so).</li></ul></li></ul></div></section><section id=updaters><h1><a href=#updaters>Updaters</a></h1><div class=content><p>The core feature of Octopilot is to update git repositories, and to do it you can use one or more of the available &ldquo;updaters&rdquo;:</p><ul><li>the <a href=#yaml>YAML updater</a>, to quickly update YAML files</li><li>the <a href=#yq>YQ updater</a>, based on <a href=https://github.com/mikefarah/yq>mikefarah&rsquo;s yq</a>, to manipulate YAML or JSON files as you want</li><li>the <a href=#helm>Helm updater</a>, to easily update the dependencies of an <a href=https://helm.sh/>Helm</a> chart</li><li>The <a href=#sops>sops updater</a>, to manipulate files encrypted with <a href=https://github.com/mozilla/sops>mozilla&rsquo;s sops</a></li><li>The <a href=#regex>regex updater</a>, to update any kind of text file using a regular expression</li><li>The <a href=#exec>exec updater</a>, to execute any command you want</li></ul><p>Each updater can be used once or more, such as:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yaml(file=config.yaml,path=&#39;version&#39;)=file(path=VERSION)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;regex(file=some-file.txt,pattern=&#39;version: \&#34;(.*)\&#34;&#39;)=</span><span class=si>${</span><span class=nv>VERSION</span><span class=si>}</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yaml(file=another-config.yaml,path=&#39;path.to.version&#39;)=</span><span class=k>$(</span>cat VERSION<span class=k>)</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div></div></section><section id=yaml><h1><a href=#yaml>YAML</a></h1><div class=content><p>The YAML updater is great when you want to quickly set a value for a specific path in one or more files. Such as if you want to update a version used in a YAML file:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yaml(file=config.yaml,path=&#39;app.version&#39;)=file(path=VERSION)&#34;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><p>Given the following <code>config.yaml</code> file:</p><div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nt>app</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>foo</span><span class=w>
</span><span class=w>  </span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=m>1.0.0</span><span class=w>
</span></code></pre></div><p>Octopilot will set the value of the <code>app.version</code> key to the content of the <code>VERSION</code> file.</p><p>The syntax is: <code>yaml(params)=value</code> - you can read more about the value in the <a href=#value>&ldquo;value&rdquo; section</a>.</p><p>It supports the following parameters:</p><ul><li><code>file</code> (string): mandatory path to the file to update. Can be a file pattern - such as <code>config/*.yaml</code> to match files in the same directory, or <code>config/**/*.yaml</code> using double asterisks (**) to match files in subdirectories. If it&rsquo;s a relative path, it will be relative to the root of the cloned git repository. For more information on using file patterns, you can refer to the <a href=https://github.com/mattn/go-zglob>go-zglob documentation</a>.</li><li><code>path</code> (string): mandatory path to the key to update in the YAML file(s). We support <a href=https://mikefarah.gitbook.io/yq/v/v3.x/usage/path-expressions>yq v3 path expressions</a> or <a href=https://mikefarah.gitbook.io/yq/operators/traverse-read>yq v4 syntax</a>.</li><li><code>indent</code> (int): optional number of spaces used for indentation when writing the YAML file(s) after update. Default to <code>2</code>.</li><li><code>trim</code> (boolean): if <code>true</code>, the content will be &ldquo;trimmed&rdquo; before being written to disk - to avoid extra line break at the end of the file for example.</li><li><code>create</code> (boolean): if <code>true</code>, then the <code>path</code> will always be set to the given value, even if no such key existed before. The default behaviour (<code>false</code>) is to NOT create any new path/key.</li><li><code>style</code> (string): an optional style to apply to the new value: <code>double</code> (add double quotes), <code>single</code> (add single quotes), <code>literal</code>, <code>folded</code> or <code>flow</code> - see <a href=https://mikefarah.gitbook.io/yq/operators/style>yq style reference</a>.</li></ul><p>Note that Octopilot will keep the comments in the YAML files - because we&rsquo;re using the great <a href=https://github.com/go-yaml/yaml/tree/v3>go-yaml v3 lib</a>. <a href=https://mikefarah.gitbook.io/yq/usage/output-format#indent>Just that it might rewrite a bit your indentation</a>.</p><p>See the <a href=#use-case-update-certs>&ldquo;updating certificates&rdquo; use-case</a> for a real-life example of what you can do with this updater.</p></div></section><section id=yq><h1><a href=#yq>YQ</a></h1><div class=content><p>The YQ updater is based on the excellent <a href=https://github.com/mikefarah/yq>yq</a> application - and Go lib. It is much more powerful than the basic <a href=#yaml>YAML updater</a> - because it supports all the <a href=https://mikefarah.gitbook.io/yq/operators>yq operators</a>, and because you are not limited to setting a value for a specific key. You can do very powerful things, such as manipulating YAML comments, use variables, output to json (note that it can also read JSON input), &mldr;</p><p>The syntax is: <code>yq(params)</code>, such as:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yq(file=config.yaml,expression=&#39;.path.to.version = strenv(VERSION)&#39;)&#34;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><p>It supports the following parameters:</p><ul><li><code>file</code> (string): mandatory path to the file to update. Can be a file pattern - such as <code>config/*.yaml</code> to match files in the same directory, or <code>config/**/*.yaml</code> using double asterisks (**) to match files in subdirectories. If it&rsquo;s a relative path, it will be relative to the root of the cloned git repository. For more information on using file patterns, you can refer to the <a href=https://github.com/mattn/go-zglob>go-zglob documentation</a>.</li><li><code>expression</code> (string): mandatory <a href=https://mikefarah.gitbook.io/yq/commands/evaluate>yq v4 expression</a> that will be evaluated against each file.</li><li><code>output</code> (string): optional output of the result. By default the result is written to the source file - in-place editing. But you can send the result to <code>stdout</code>, <code>stderr</code> or a specific file.</li><li><code>json</code> (boolean): if <code>true</code>, then the output will be written in JSON format instead of YAML format.</li><li><code>indent</code> (int): optional number of spaces used for indentation when writing the YAML file(s) after update. See <a href=https://mikefarah.gitbook.io/yq/usage/output-format#indent>yq doc on indent</a>. Default to <code>2</code>.</li><li><code>trim</code> (boolean): if <code>true</code>, the content will be &ldquo;trimmed&rdquo; before being written to disk - to avoid extra line break at the end of the file for example.</li><li><code>unwrapscalar</code> (boolean): if <code>true</code> (the default), only the value will be printed - not the comments. See <a href=https://mikefarah.gitbook.io/yq/usage/output-format#unwrap-scalars>yq doc on unwrap scalars</a>.</li></ul><p>Note that Octopilot will keep the comments in the YAML files - because we&rsquo;re using the great <a href=https://github.com/go-yaml/yaml/tree/v3>go-yaml v3 lib</a>. <a href=https://mikefarah.gitbook.io/yq/usage/output-format#indent>Just that it might rewrite a bit your indentation</a>.</p><p>See the <a href=#use-case-app-promotion>&ldquo;promoting a new application release&rdquo; use-case</a> for a real-life example of what you can do with this updater.</p></div></section><section id=helm><h1><a href=#helm>Helm</a></h1><div class=content><p>The Helm updater is made to easily update the dependencies of one or more <a href=https://helm.sh/>Helm</a> charts. It supports both:</p><ul><li>Helm v3, with the dependencies declared in the <code>Chart.yaml</code> file</li><li>Helm v2, with the dependencies declared in the <code>requirements.yaml</code> file</li></ul><p>If you run the following command:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;helm(dependency=chart-name)=1.2.3&#34;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><p>Octopilot will discover all charts stored in the cloned repository, and for each, try to change the version of the <code>chart-name</code> dependency to <code>1.2.3</code>.</p><p>The syntax is: <code>helm(params)=value</code> - you can read more about the value in the <a href=#value>&ldquo;value&rdquo; section</a>.</p><p>It supports the following parameters:</p><ul><li><code>dependency</code> (string): mandatory name of the dependency to update. Must exist in the dependencies list - it won&rsquo;t be added.</li><li><code>indent</code> (int): optional number of spaces used for indentation when writing the YAML file(s) after update. Default to <code>2</code>.</li></ul><p>Note that Octopilot will keep the comments in the YAML files - because we&rsquo;re using the great <a href=https://github.com/go-yaml/yaml/tree/v3>go-yaml v3 lib</a>. <a href=https://mikefarah.gitbook.io/yq/usage/output-format#indent>Just that it might rewrite a bit your indentation</a>.</p><p>See the <a href=#use-case-lib-promotion>&ldquo;promoting a new library release&rdquo; use-case</a> for a real-life example of what you can do with this updater.</p></div></section><section id=sops><h1><a href=#sops>Sops</a></h1><div class=content><p>The <strong>sops</strong> updater can manipulate files encrypted with <a href=https://github.com/mozilla/sops>mozilla&rsquo;s sops</a> natively, without the need to install <a href=https://github.com/mozilla/sops>sops</a>. This is great if you want to store sensitive data in your git repositories: you can encrypt them with <code>sops</code>, and use Octopilot to update them automatically.</p><p>For example if you want to store your TLS certificate as a base64 encoded string in a sops-encrypted file:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=sb>`</span>sops<span class=o>(</span><span class=nv>file</span><span class=o>=</span>secrets.yaml,key<span class=o>=</span>app.tls.base64encodedCertificateKey<span class=o>)=</span><span class=k>$(</span>kubectl -n cert-manager get secrets tls-myapp -o <span class=nv>template</span><span class=o>=</span><span class=s1>&#39;{{index .data &#34;tls.key&#34;}}&#39;</span><span class=k>)</span><span class=sb>`</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><p>Given the following (decrypted) <code>secrets.yaml</code> file:</p><div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nt>app</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>tls</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>base64encodedCertificateKey</span><span class=p>:</span><span class=w> </span><span class=l>LS0tLS1CRUdJTiBSU0EgU...</span><span class=w>
</span></code></pre></div><p>Octopilot will decrypt the <code>secrets.yaml</code> file, set the value of the <code>app.tls.base64encodedCertificateKey</code> key to the given value, and re-encrypt the <code>secrets.yaml</code> file before writing it to disk.</p><p>The syntax is: <code>sops(params)=value</code> - you can read more about the value in the <a href=#value>&ldquo;value&rdquo; section</a>.</p><p>It supports the following parameters:</p><ul><li><code>file</code> (string): mandatory path to the file to update. Can be a file pattern - such as <code>config/secrets.*</code> to match files in the same directory, or <code>config/**/secrets.*</code> using double asterisks (**) to match files in subdirectories. If it&rsquo;s a relative path, it will be relative to the root of the cloned git repository. For more information on using file patterns, you can refer to the <a href=https://github.com/mattn/go-zglob>go-zglob documentation</a>.</li><li><code>key</code> (string): mandatory key to update in the file(s).</li></ul><p>Note that depending on the sops backend you use (KMS, age, vault, &mldr;) you might need to set some environment variables, such as:</p><ul><li>for GCP KMS, the <code>GOOGLE_APPLICATION_CREDENTIALS</code> env var</li><li>for <a href=https://age-encryption.org/>age</a>, the <code>SOPS_AGE_KEY_FILE</code> env var</li><li>&mldr;</li></ul><p>See the <a href=#use-case-update-certs>&ldquo;updating certificates&rdquo; use-case</a> for a real-life example of what you can do with this updater.</p></div></section><section id=regex><h1><a href=#regex>Regex</a></h1><div class=content><p>The <strong>regex</strong> updater can be used to update any kind of text file using a regular expression - with the <a href=https://golang.org/pkg/regexp/syntax/>Golang syntax</a>, such as:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;regex(file=some-file.txt,pattern=&#39;version: \&#34;(.*)\&#34;&#39;)=</span><span class=si>${</span><span class=nv>VERSION</span><span class=si>}</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><p>Given the following <code>some-file.txt</code> file:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>version: &#34;1.0.0&#34;
...
</code></pre></div><p>Octopilot will replace the first line with <code>version: "1.2.3"</code> if the <code>$VERSION</code> env var is set to <code>1.2.3</code> for example.</p><p>The syntax is: <code>regex(params)=value</code> - you can read more about the value in the <a href=#value>&ldquo;value&rdquo; section</a>.</p><p>It supports the following parameters:</p><ul><li><code>file</code> (string): mandatory path to the file to update. Can be a file pattern - such as <code>files/*.txt</code> to match files in the same directory, or <code>files/**/*.txt</code> using double asterisks (**) to match files in subdirectories. If it&rsquo;s a relative path, it will be relative to the root of the cloned git repository. For more information on using file patterns, you can refer to the <a href=https://github.com/mattn/go-zglob>go-zglob documentation</a>.</li><li><code>pattern</code> (string): mandatory regex pattern to find and replace something in the file(s). The pattern must be in the <a href=https://golang.org/pkg/regexp/syntax/>Golang syntax</a>. If this pattern includes a capturing group, then it will be replaced by the provided value.</li></ul><p>A few things you can do with the regex updater:</p><ul><li>replace the whole content of a file<div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;regex(file=my-file,pattern=&#39;(?ms)(.*)&#39;)=new content&#34;</span> 
</code></pre></div></li></ul></div></section><section id=exec><h1><a href=#exec>Exec</a></h1><div class=content><p>The <strong>exec</strong> updater can execute any command you want, so you can change files in the cloned git repository with any tool you have available.</p><p>For example to update all your Go dependencies to the latest version:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;exec(cmd=go,args=get -d -t -u)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;exec(cmd=go,args=mod tidy)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;exec(cmd=go,args=mod vendor)&#34;</span> <span class=se>\
</span><span class=se></span>    --git-stage-pattern <span class=s2>&#34;vendor&#34;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><p>This will execute 3 commands, that will update the <code>go.mod</code> & <code>go.sum</code> files, and the <code>vendor</code> dir. Octopilot will then add/commit all the changes, including the new files in the <code>vendor</code> directory.</p><p>The syntax is: <code>exec(params)</code>.</p><p>It supports the following parameters:</p><ul><li><code>cmd</code> (string): mandatory command to execute.</li><li><code>path</code> (string): optional path to execute the command in.</li><li><code>args</code> (string): optional arguments for the command. The arguments are space-separated. If you have a space in an argument, you can quote it, such as: <code>-c 'some arg' -x another</code>.</li><li><code>stdout</code> (string): optional path to a file where the std output of the command will be written. If it&rsquo;s a relative path, it will be relative to the root of the cloned git repository.</li><li><code>stderr</code> (string): optional path to a file where the std error output of the command will be written. If it&rsquo;s a relative path, it will be relative to the root of the cloned git repository.</li><li><code>timeout</code> (string/duration): optional maximum duration to wait for the command to finish, using the <a href=https://golang.org/pkg/time/#ParseDuration>Golang syntax</a>.</li></ul><p>A few things you can do with the regex updater:</p><ul><li><p>use a bash command to enable shell expansion (disabled by default when invoking commands through Octopilot)</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;exec(cmd=sh,args=-c &#39;cat files/*.txt&#39;,stdout=output.txt)&#34;</span>
</code></pre></div></li><li><p>use the an external tool (here kustomize) and change the current working directory before executing the command</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;exec(cmd=kustomize, path=k8s/overlays/dev, args=edit set image containername=registry.tld/repo/image:newtag)&#34;</span>
</code></pre></div></li></ul><p>See the <a href=#use-case-go-deps>&ldquo;updating go dependencies&rdquo; use-case</a> for a real-life example of what you can do with this updater.</p></div></section><section id=value><h1><a href=#value>Value</a></h1><div class=content><p>Some updaters accept a <strong>value</strong> in their syntax, such as <code>updater(params)=value</code>.</p><p>This value can be either:</p><ul><li>a raw value</li><li>the content of a file</li></ul><h2 id=raw-value>Raw value</h2><p>This is the easiest way to set a value: just use a raw value, such as:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yaml(file=config.yaml,path=&#39;version&#39;)=v1.2.3&#34;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><p>Note that you can also use an environment variable:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>export</span> <span class=nv>VERSION</span><span class=o>=</span>v1.2.3
$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yaml(file=config.yaml,path=&#39;version&#39;)=</span><span class=si>${</span><span class=nv>VERSION</span><span class=si>}</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><p>or any command you want:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>echo</span> v1.2.3 &gt; /tmp/VERSION
$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yaml(file=config.yaml,path=&#39;version&#39;)=</span><span class=k>$(</span>cat /tmp/VERSION<span class=k>)</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><h2 id=file-content>File content</h2><p>If you want to use the content of a file, you can use the <strong>file</strong> valuer:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yaml(file=config.yaml,path=&#39;version&#39;)=file(path=VERSION)&#34;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div><p>It will read the <code>VERSION</code> file located at the root of the cloned git repository, and use its content as the value.</p><p>The syntax is: <code>file(params)</code>.</p><p>It supports the following parameters:</p><ul><li><code>path</code> (string): mandatory path to the file to read. If it&rsquo;s a relative path, it will be relative to the root of the cloned git repository.</li></ul></div></section><section id=github-auth><h1><a href=#github-auth>GitHub Auth</a></h1><div class=content><p>Octopilot needs a way to authenticate against the GitHub API, to:</p><ul><li>clone the repositories</li><li>push new changes</li><li>and create/update/merge Pull Requests</li></ul><p>It supports 2 ways to authenticate:</p><ul><li>using a personal access <strong>token</strong>, which is the default</li><li>using a GitHub <strong>app</strong></li></ul><p>You can define which method to use, using the <code>--github-auth-method</code> CLI flag.</p><h2 id=personal-access-token>Personal Access Token</h2><p>By default, the <code>--github-auth-method</code> flag is set to <code>token</code>, so Octopilot will use a <strong>Personal Access Token</strong> - or <code>PAT</code>. This token can be defined either by the <code>GITHUB_TOKEN</code> environment variable, or by setting the <code>--github-token</code> CLI flag.</p><p>You can read GitHub&rsquo;s documentation on <a href=https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token>creating a personal access token</a>. You&rsquo;ll need at least the <code>repo</code> permissions.</p><h2 id=github-app>GitHub App</h2><p>An alternative to the &ldquo;simple&rdquo; token is to use a <a href=https://docs.github.com/en/developers/apps>GitHub App</a>.</p><p>First, you&rsquo;ll need to set the <code>--github-auth-method</code> flag value to <code>app</code>, and then configure the following settings:</p><ul><li><code>--github-app-id</code> (int): the GitHub App ID. Default to the value of the <code>GITHUB_APP_ID</code> environment variable.</li><li><code>--github-installation-id</code> (int): the GitHub App installation ID. Default to the value of the <code>GITHUB_INSTALLATION_ID</code> environment variable.</li><li><code>--github-privatekey</code> (string): the app&rsquo;s private key - used to sign access token requests - in PEM format. Default to the value of the <code>GITHUB_PRIVATEKEY</code> environment variable. You can either set this, or the <code>--github-privatekey-path</code>.</li><li><code>--github-privatekey-path</code> (string): the path to the app&rsquo;s private key - used to sign access token requests - in PEM format. Default to the value of the <code>GITHUB_PRIVATEKEY_PATH</code> environment variable. Will be used if the <code>--github-privatekey</code> flag is not set.</li></ul><p>See GitHub&rsquo;s documentation for more details on:</p><ul><li><a href=https://docs.github.com/en/developers/apps/building-github-apps/creating-a-github-app>Creating a GitHub App</a></li><li><a href=https://docs.github.com/en/developers/apps/building-github-apps/authenticating-with-github-apps>Authenticating with GitHub Apps</a></li></ul><h2 id=using-octopilot-with-enterprise-github>Using octopilot with Enterprise GitHub</h2><p>By default, octopilot will operate on repositories hosted on <a href=https://github.com>https://github.com</a>. Octopilot can work on repositories hosted on an Enterprise Github servers by adding the <code>--github-url</code> flag.
This flag must be set to the URL of the Enterprise GitHub server (the URL used to browse to the GitHub server main page). Authentication is usually required using any of the authentication method described above.</p><p>Example of use:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>
$ octopilot <span class=se>\
</span><span class=se></span>    --github-url https://mygitserver.acme.com <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;</span><span class=si>${</span><span class=nv>ORG_NAME</span><span class=si>}</span><span class=s2>/test-repo&#34;</span> <span class=se>\
</span><span class=se></span>    ...
</code></pre></div></div></section><section id=advanced><h1><a href=#advanced>Advanced</a></h1><div class=content><p>Octopilot advanced features:</p><ul><li><a href=#templating>Templating</a></li></ul></div></section><section id=templating><h1><a href=#templating>Templating</a></h1><div class=content><p>For some of the CLI flags - such as commit title/body or Pull Requests title/body - you can use our &ldquo;templating&rdquo; feature. This will allow you to write nice commits and Pull Requests.</p><p>Octopilot uses the <a href=https://pkg.go.dev/text/template>Go template</a> syntax, and supports the following functions:</p><ul><li>all the <a href=https://golang.org/pkg/text/template/#hdr-Functions>Go template functions</a></li><li>all the <a href=http://masterminds.github.io/sprig/>sprig functions</a></li><li>Octopilot&rsquo;s own custom functions</li></ul><h2 id=octopilots-own-custom-functions>Octopilot&rsquo;s own custom functions</h2><p>Octopilot comes with the following custom functions:</p><ul><li><code>readFile</code> to read a file from the cloned git repository, and return its content</li><li><code>githubRelease</code> to retrieve the release notes for a specific GitHub release</li><li><code>expandGithubLinks</code> to transform GitHub short links - such as #123 - to absolute URLs</li><li><code>extractMarkdownURLs</code> to transform markdown links to plain URLs</li><li><code>md2txt</code> to strip all the markdown syntax from a string</li></ul><h3 id=readfile>readFile</h3><p>The <code>readFile</code> function will read a file from the cloned git repository, and return its content as a string. If the path of the file is relative, it will be relative to the root of the git repository.</p><p>Definition: <code>readFile(filePath string) string</code>.</p><p>Example: <code>{{readFile "README.md"}}</code> to print the content of the <code>README.md</code> file.</p><h3 id=githubrelease>githubRelease</h3><p>The <code>githubRelease</code> function will retrieve the release notes for a specific GitHub release. The release is identified by the owner, repository and release version.</p><p>Definition: <code>githubRelease(releaseID string) string</code>.</p><p>Example: <code>{{ githubRelease "owner/repo/v1.2.3" }}</code> to print the release notes for the release <code>v1.2.3</code> of the <code>owner/repo</code> github repository.</p><h3 id=expandgithublinks>expandGithubLinks</h3><p>The <code>expandGithubLinks</code> function will transform GitHub short links - such as #123 - to absolute URLs. It is most useful when combined with the <code>githubRelease</code> function, to ensure that the links in the release notes are always absolute.</p><p>Definition: <code>expandGithubLinks(fullRepositoryName string, markdownInput string) string</code>. The <code>fullRepositoryName</code> parameter is the full name of the repository, such as <code>owner/repo</code>. It is used to build the absolute URLs.</p><p>Example: <code>{{ githubRelease (print "owner/repo/" (env "VERSION")) | expandGithubLinks "owner/repo" }}</code>.</p><h3 id=extractmarkdownurls>extractMarkdownURLs</h3><p>The <code>extractMarkdownURLs</code> function will transform markdown links to plain URLs. It is most useful when combined with the <code>githubRelease</code> function, to ensure that the links in the release notes are always plain URLs - when you want to print plain text, and not markdown, such as in a commit message.</p><p>Definition: <code>extractMarkdownURLs(markdownInput string) string</code>.</p><p>Example: <code>{{ githubRelease (print "owner/repo/" (env "VERSION")) | expandGithubLinks "owner/repo" | extractMarkdownURLs }}</code>.</p><h3 id=md2txt>md2txt</h3><p>The <code>md2txt</code> function will strip all the markdown syntax from a string. It is most useful when combined with the <code>githubRelease</code> function, to ensure that the release notes are always plain text, and not markdown. Use it for your commit messages.</p><p>Definition: <code>md2txt(markdownInput string) string</code>.</p><p>Example: <code>{{ githubRelease (print "owner/repo/" (env "VERSION")) | expandGithubLinks "owner/repo" | extractMarkdownURLs | md2txt }}</code>.</p></div></section><section id=use-cases><h1><a href=#use-cases>Use cases</a></h1><div class=content><p>If you want to see what you can do with Octopilot for real, here is a set of real-world use-cases that we have at <a href=https://www.dailymotion.com/>Dailymotion</a>:</p><ul><li><a href=#use-case-app-promotion>Promoting a new application release</a> with a gitops workflow</li><li><a href=#use-case-lib-promotion>Promoting a new library release</a> to a dynamic list of application repositories</li><li><a href=#use-case-update-certs>Updating certificates</a> with a gitops workflow</li><li><a href=#use-case-go-deps>Updating Go dependencies</a></li><li><a href=#use-case-preview>Previsualizing changes</a> done by octopilot, without pushing to the remote GitHub repository</li></ul></div></section><section id=use-case-app-promotion><h1><a href=#use-case-app-promotion>Promoting a new application release</a></h1><div class=content><p>If you&rsquo;re doing gitops, you&rsquo;ll most likely have:</p><ul><li>at least one &ldquo;application&rdquo; git repository, for your(s) application(s).</li><li>at least one &ldquo;environment&rdquo; git repository, for your(s) environment(s).</li></ul><p>When you release a new version of your application, you&rsquo;ll need to &ldquo;promote&rdquo; it to (at least) one of your environments. In the gitops world, we&rsquo;re doing that by creating a new Pull Request against the target environment git repository, to update the version of the application in a configuration file.</p><p>And this is where Octopilot shines. You can use it in your application&rsquo;s Continuous Delivery pipeline to create the Pull Request against your environment&rsquo;s git repository.</p><p>Let&rsquo;s see an example, where we want to:</p><ul><li>automatically deploy new releases in the staging environment</li><li>manually deploy new releases in the production environment</li></ul><p>To do that, we&rsquo;ll:</p><ul><li>create a Pull Request on the <code>staging-env</code> git repository, and ask Octopilot to automatically merge it - and thus deploying it</li><li>create a Pull Request on the <code>prod-env</code> git repository, but not merge it. We&rsquo;ll even create the Pull Request as a &ldquo;draft&rdquo;, making it explicit that the release is not ready yet.</li></ul><p>Oh, and we&rsquo;d like to get nice commit messages and Pull Request title/description, so that people can understand what really is changing with this Pull Request. If all you have is &ldquo;Update my-app to version 1.2.3&rdquo;, and a diff that shows a version change in a config file, it won&rsquo;t help you understand if this release is just fixing a typo in a README, fixing a critical bug, or introducing a new feature. We&rsquo;re already generating release notes with a changelog - if not, you should, using <a href=https://github.com/git-chglog/git-chglog>git-chglog</a> for example - so let&rsquo;s re-use it and include it in our commit messages and Pull Request.</p><p>Here is an example of an Octopilot invocation you can use to achieve our goal - we&rsquo;ll go over it in details later:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>export</span> <span class=nv>GITHUB_TOKEN</span><span class=o>=</span>&lt;your_github_token&gt;
$ <span class=nb>export</span> <span class=nv>ORG_NAME</span><span class=o>=</span>my-org
$ <span class=nb>export</span> <span class=nv>APP_NAME</span><span class=o>=</span>my-app
$ <span class=nb>export</span> <span class=nv>VERSION</span><span class=o>=</span>1.2.3
$ octopilot <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;</span><span class=si>${</span><span class=nv>ORG_NAME</span><span class=si>}</span><span class=s2>/staging-env(merge=true)&#34;</span> <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;</span><span class=si>${</span><span class=nv>ORG_NAME</span><span class=si>}</span><span class=s2>/prod-env(draft=true)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yq(file=helmfile.yaml,expression=&#39;.releases[] | select(.name == strenv(APP_NAME)) | .version&#39;,output=.git/previous-version.txt)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yq(file=helmfile.yaml,expression=&#39;(.releases[] | select(.name == strenv(APP_NAME)) | .version) = strenv(VERSION)&#39;)&#34;</span> <span class=se>\
</span><span class=se></span>    --git-commit-title <span class=s1>&#39;chore(deps): update {{ env &#34;APP_NAME&#34; }} from {{ readFile &#34;.git/previous-version.txt&#34; | trim }} to {{ env &#34;VERSION&#34; }}&#39;</span> <span class=se>\
</span><span class=se></span>    --git-commit-body <span class=s1>&#39;{{ githubRelease (printf &#34;%s/%s/v%s&#34; (env &#34;ORG_NAME&#34;) (env &#34;APP_NAME&#34;) (env &#34;VERSION&#34;)) | expandGithubLinks (printf &#34;%s/%s&#34; (env &#34;ORG_NAME&#34;) (env &#34;APP_NAME&#34;)) | extractMarkdownURLs | md2txt }}&#39;</span> <span class=se>\
</span><span class=se></span>    --git-branch-prefix <span class=s2>&#34;octopilot-update-</span><span class=si>${</span><span class=nv>APP_NAME</span><span class=si>}</span><span class=s2>-&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-labels <span class=s2>&#34;update-</span><span class=si>${</span><span class=nv>APP_NAME</span><span class=si>}</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-title <span class=s2>&#34;Update </span><span class=si>${</span><span class=nv>APP_NAME</span><span class=si>}</span><span class=s2> to </span><span class=si>${</span><span class=nv>VERSION</span><span class=si>}</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-title-update-operation <span class=s2>&#34;replace&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-body <span class=s1>&#39;{{ githubRelease (printf &#34;%s/%s/v%s&#34; (env &#34;ORG_NAME&#34;) (env &#34;APP_NAME&#34;) (env &#34;VERSION&#34;)) | expandGithubLinks (printf &#34;%s/%s&#34; (env &#34;ORG_NAME&#34;) (env &#34;APP_NAME&#34;)) }}&#39;</span> <span class=se>\
</span><span class=se></span>    --pr-body-update-operation <span class=s2>&#34;prepend&#34;</span> <span class=se>\
</span><span class=se></span>    --strategy <span class=s2>&#34;append&#34;</span>
</code></pre></div><p>As you can see, we&rsquo;re making the same set of changes to 2 different repositories, with different configurations:</p><ul><li>the PR on the <code>staging-env</code> repository will be automatically merged - and thus our release deployed</li><li>the PR on the <code>prod-env</code> repository will be created as &ldquo;draft&rdquo;, and won&rsquo;t be automatically merged - thus requiring a human intervention to merge it</li></ul><p>We&rsquo;re running the <a href=#yq>YQ updater</a> twice, on the same <code>helmfile.yaml</code> file, which would look like the following:</p><div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nt>releases</span><span class=p>:</span><span class=w>
</span><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-app</span><span class=w>
</span><span class=w>    </span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=m>1.0.0</span><span class=w>
</span><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>another-app</span><span class=w>
</span><span class=w>    </span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=m>1.5.0</span><span class=w>
</span></code></pre></div><p>This is a very simplified configuration file for <a href=https://github.com/roboll/helmfile>helmfile</a>, an application used to describe <a href=http://helm.sh/>Helm</a> releases. You can use whatever you want, it&rsquo;s just to base our example on a real-life use-case.</p><p>So we&rsquo;re running the <a href=#yq>YQ updater</a> twice:</p><ul><li>the first time, with the <code>.releases[] | select(.name == strenv(APP_NAME)) | .version</code> expression, to extract the current version for our application named <code>my-app</code>. And we&rsquo;re sending the output to the <code>.git/previous-version.txt</code> file - which will contain just <code>1.0.0</code>. We&rsquo;re doing that to store the &ldquo;previous&rdquo; version before changing it without new version. You&rsquo;ll notice that the output file is located in the <code>.git</code> directory, this is to avoid committing it by default.</li><li>the second time, we&rsquo;re replacing the version with the new one - stored in the <code>VERSION</code> environment variable - with the following expression: <code>(.releases[] | select(.name == strenv(APP_NAME)) | .version) = strenv(VERSION)</code>.</li></ul><p>Now, we have:</p><ul><li>a locally modified <code>helmfile.yaml</code></li><li>a new <code>.git/previous-version.txt</code> file</li></ul><p>So it&rsquo;s time to commit!</p><ul><li>in the commit title, we want to include both the previous version and the new version. We&rsquo;ll use the <a href=#templating>templating feature</a> to include both the content of a file and an environment variable: <code>chore(deps): update {{ env "APP_NAME" }} from {{ readFile ".git/previous-version.txt" | trim }} to {{ env "VERSION" }}</code></li><li>in the commit body, we want to include the release notes for the new version. We&rsquo;ll use the <a href=#templating>templating feature</a> to retrieve the release notes, convert all the GitHub short links to absolute URLs, and transform the markdown into raw text: <code>{{ githubRelease (printf "%s/%s/v%s" (env "ORG_NAME") (env "APP_NAME") (env "VERSION")) | expandGithubLinks (printf "%s/%s" (env "ORG_NAME") (env "APP_NAME")) | extractMarkdownURLs | md2txt }}</code></li></ul><p>We&rsquo;ll also use a custom prefix for the branch name, to make it easier to find which branch belongs to which app, if you have multiple promotion PRs for different applications opened at the same time.</p><p>Next, the Pull Request. We&rsquo;ll use the <code>append</code> strategy, which means that if we need to promote a release in prod, and the previous one hasn&rsquo;t been merged/deployed yet, we&rsquo;ll just append a new commit on the existing branch/PR. So that your production PR for your application will stay the same, accumulating releases until it is merged. We&rsquo;re using a specific label for our Pull Request: <code>update-${APP_NAME}</code> - to make sure we&rsquo;ll find any existing PR for our application, and that each application will get its own PR.</p><p>Same as for the commit, we&rsquo;ll use the <a href=#templating>templating feature</a> to write a nice title and description for our Pull Request - just that this time we won&rsquo;t need to convert from markdown to raw text. And we&rsquo;ll use specific &ldquo;update operations&rdquo;:</p><ul><li>we&rsquo;ll always replace the PR title, because we want a short title, with only the app name and the latest release&rsquo;s version - using the <code>--pr-title-update-operation "replace"</code> flag</li><li>we&rsquo;ll &ldquo;prepend&rdquo; the new PR body, before the existing one, using the <code>--pr-body-update-operation "prepend"</code> flag. So that the release notes for the latest release will be first - just as when you read a changelog. And of course we don&rsquo;t want to remove the previous release notes.</li></ul><h2 id=result>Result</h2><h3 id=staging-environment>Staging environment</h3><p>This is a screenshot of a Pull Request on the staging environment git repository, which has been automatically merged. You can see the release notes, and you&rsquo;ll notice the &ldquo;signature&rdquo; at the bottom: we&rsquo;re making it easy for people to know:</p><ul><li>that this PR has been generated by an application - and not created manually by a human</li><li>which version of Octopilot has been used</li><li>from where it has been executed. This will most likely be the application&rsquo;s GitHub repository, because it is where you (should) define your application&rsquo;s Continuous Delivery pipeline, which contains a step to execute Octopilot.</li></ul><p><img src=screenshot-app-promotion-pr-single-commit.png alt></p><h3 id=production-environment>Production environment</h3><p>This is a screenshot of a Pull Request on the production environment git repository:</p><ul><li>the PR has been created to promote <code>v3.14.1</code> of the application</li><li>later, <code>v3.15.0</code> has been released - and promoted. Thus adding a new commit to the PR</li><li>and then, <code>some-user</code> merged the Pull Request, to deploy in prod</li></ul><p>You&rsquo;ll notice that we have 2 release notes in the PR: 1 for each release. So you can see the full changelog for every release that will be deployed when you&rsquo;ll merge this PR.</p><p><img src=screenshot-app-promotion-pr-multi-commits.png alt></p><p>In this screenshot you can see the 2 commits:</p><p><img src=screenshot-app-promotion-pr-multi-commits-commits.png alt></p><h3 id=feedback>Feedback</h3><p>The benefit of adding the application&rsquo;s release notes in the promotion pull request body, is that not only will you know exactly what you&rsquo;ll deploy, but you&rsquo;ll also get links between the application pull request and the promotion pull requests. So that if you go back to the application&rsquo;s PR, you&rsquo;ll see something like:</p><p><img src=screenshot-app-promotion-pr-feedback.png alt></p><p>You can see at the bottom the links to our 2 promotion pull requests, with their statuses - both have been merged already in this case.</p><h2 id=going-further>Going further</h2><p>As you can see, it&rsquo;s easy to adapt this example for your own use-case. For example, you might want:</p><ul><li>to create PRs on a different set of <a href=#repos>repositories</a>: QA, staging and production</li><li>to update different kinds of files, using different <a href=#updaters>updaters</a></li><li>to customize the <a href=#commit>commit</a> or the <a href=#pull-request>Pull Request</a></li></ul></div></section><section id=use-case-lib-promotion><h1><a href=#use-case-lib-promotion>Promoting a new library release</a></h1><div class=content><p>Promoting a new release of a library is similar to <a href=#use-case-app-promotion>promoting a new release of an application</a>, except that instead of promoting to a small number of git repositories - representing the different environments - you will promote to a much larger number of git repositories: one for each application using the library.</p><p>The main change is that instead of using a <a href=#static>static list</a> of repositories, you can use a <a href=#dynamic>dynamic list</a> of repositories - based on a <a href=https://docs.github.com/en/github/searching-for-information-on-github/searching-on-github/searching-for-repositories>GitHub Repositories Search Query</a> or a <a href=https://docs.github.com/en/search-github/searching-on-github/searching-code>GitHub Code Search Query</a> for example.</p><h2 id=github-repositories-search-query>GitHub Repositories Search Query</h2><p>Here is an example of an Octopilot invocation using a dynamic list of repos and GitHub Repositories Search Query - we&rsquo;ll go over it in details later:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>export</span> <span class=nv>GITHUB_TOKEN</span><span class=o>=</span>&lt;your_github_token&gt;
$ <span class=nb>export</span> <span class=nv>VERSION</span><span class=o>=</span>1.0.15
$ octopilot <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(query=org:my-org topic:octopilot-my-base-chart)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;helm(dependency=my-base-chart)=</span><span class=si>${</span><span class=nv>VERSION</span><span class=si>}</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    --git-commit-title <span class=s1>&#39;chore(deps): update my-base-chart to {{ env &#34;VERSION&#34; }}&#39;</span> <span class=se>\
</span><span class=se></span>    --git-commit-body <span class=s1>&#39;{{ githubRelease (printf &#34;my-org/my-base-chart/v%s&#34; (env &#34;VERSION&#34;)) | expandGithubLinks &#34;my-org/my-base-chart&#34; | extractMarkdownURLs | md2txt }}&#39;</span> <span class=se>\
</span><span class=se></span>    --git-branch-prefix <span class=s2>&#34;octopilot-update-my-base-chart-&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-labels <span class=s2>&#34;update-my-base-chart&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-title <span class=s2>&#34;Update Helm Base Chart to </span><span class=si>${</span><span class=nv>VERSION</span><span class=si>}</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-title-update-operation <span class=s2>&#34;replace&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-body <span class=s1>&#39;{{ githubRelease (printf &#34;my-org/my-base-chart/v%s&#34; (env &#34;VERSION&#34;)) | expandGithubLinks &#34;my-org/my-base-chart&#34; }}&#39;</span> <span class=se>\
</span><span class=se></span>    --pr-body-update-operation <span class=s2>&#34;prepend&#34;</span> <span class=se>\
</span><span class=se></span>    --strategy <span class=s2>&#34;append&#34;</span>
</code></pre></div><p>We&rsquo;re using the following GitHub Repositories search query to discover the repositories that are using the <code>my-base-chart</code> Helm chart:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>query=org:my-org topic:octopilot-my-base-chart
</code></pre></div><p>Which means that developers just need to add the <code>octopilot-my-base-chart</code> topic to their repositories - in the GitHub UI - to enable automatic update of the Helm base chart. It&rsquo;s easy to add, and easy to turn off if you don&rsquo;t want it. Note that you are not limited to searching by topic - you can also search for specific content in the repository&rsquo;s name, description, <code>README.md</code> file, and so on.</p><p>We&rsquo;re using the <a href=#helm>Helm updater</a> to update all the <a href=https://helm.sh/>Helm</a> charts, and set the version of their dependency on <code>my-base-chart</code> to the new release version.</p><p>Everything else is similar to the <a href=#use-case-app-promotion>promotion of a new application release</a>.</p><h2 id=github-code-search-query>GitHub Code Search Query</h2><p>This search type is useful in case you experience some limitations with the default <code>Repositories</code> one</p><ul><li>50 characters max</li><li>20 topics max per repository</li></ul><p>Here is an example of an Octopilot invocation using a dynamic list of repos and GitHub Code Search Query - we&rsquo;ll go over it in details later:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>export</span> <span class=nv>GITHUB_TOKEN</span><span class=o>=</span>&lt;your_github_token&gt;
$ <span class=nb>export</span> <span class=nv>VERSION</span><span class=o>=</span>1.0.15
$ octopilot <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;discover-from(searchtype=code,query=org:my-org filename:Chart.yaml path:charts my-base-chart)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yaml(file=charts/*/Chart.yaml,path=dependencies.(name==my-base-chart).version,style=folded)=</span><span class=si>${</span><span class=nv>VERSION</span><span class=si>}</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    --git-commit-title <span class=s1>&#39;chore(deps): update my-base-chart to {{ env &#34;VERSION&#34; }}&#39;</span> <span class=se>\
</span><span class=se></span>    --git-commit-body <span class=s1>&#39;{{ githubRelease (printf &#34;my-org/my-base-chart/v%s&#34; (env &#34;VERSION&#34;)) | expandGithubLinks &#34;my-org/my-base-chart&#34; | extractMarkdownURLs | md2txt }}&#39;</span> <span class=se>\
</span><span class=se></span>    --git-branch-prefix <span class=s2>&#34;octopilot-update-my-base-chart-&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-labels <span class=s2>&#34;update-my-base-chart&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-title <span class=s2>&#34;Update Helm Base Chart to </span><span class=si>${</span><span class=nv>VERSION</span><span class=si>}</span><span class=s2>&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-title-update-operation <span class=s2>&#34;replace&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-body <span class=s1>&#39;{{ githubRelease (printf &#34;my-org/my-base-chart/v%s&#34; (env &#34;VERSION&#34;)) | expandGithubLinks &#34;my-org/my-base-chart&#34; }}&#39;</span> <span class=se>\
</span><span class=se></span>    --pr-body-update-operation <span class=s2>&#34;prepend&#34;</span> <span class=se>\
</span><span class=se></span>    --strategy <span class=s2>&#34;append&#34;</span>
</code></pre></div><p>We can use the following GitHub Code search type and query to discover the repositories that are using the <code>my-base-chart</code> Helm chart:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>searchtype=code,query=org:my-org filename:Chart.yaml path:charts my-base-chart
</code></pre></div><p>By default <code>searchtype</code> is equal to <code>repositories</code>, because here we need to use the Github Code Search query, we have to put it to code.
With Github Code Search query, developers don&rsquo;t need to do anything to enable automatic update of their Helm base chart.</p><p>We&rsquo;re using the <a href=#helm>Helm updater</a> to update all the <a href=https://helm.sh/>Helm</a> charts, and set the version of their dependency on <code>my-base-chart</code> to the new release version.</p><p>Everything else is similar to the <a href=#use-case-app-promotion>promotion of a new application release</a>.</p><h2 id=result>Result</h2><p>This is the screenshot of the bottom of the library PR which is at the origin of the promotion - and which is referenced in the library&rsquo;s release notes.</p><p><img src=screenshot-lib-promotion-pr-feedback.png alt></p><p>You can see that multiple promotion pull requests have been created, one per repository matching the GitHub search query. This is an easy way to see which application repositories have upgraded to the new version of the library.</p></div></section><section id=use-case-update-certs><h1><a href=#use-case-update-certs>Updating certificates</a></h1><div class=content><p>One of the questions you will have to answer when doing gitops is: &ldquo;where do I stop?&rdquo;. What do you store in your environment git repository? For example, should you store your certificates there too, or do you consider them &ldquo;outside&rdquo; of the gitops-scope, and so managed by something else, such as <a href=https://cert-manager.io/>cert-manager</a>?</p><p>Let&rsquo;s say we want to manage them with our gitops process. It means that we&rsquo;ll need to:</p><ul><li>store them in a git repository. It&rsquo;s not a problem for the certificate itself, but we&rsquo;ll need to ensure that the private key won&rsquo;t be stored in cleartext.</li><li>update the git repository every time a new certificate is issued - ideally by automatically creating a Pull Request.</li></ul><p>In a Kubernetes environment where you have multiple clusters - for example in different regions of the world, different environments, etc - we can setup and use <a href=https://cert-manager.io/>cert-manager</a> to manage the certificates from a &ldquo;central&rdquo; cluster. No need to setup cert-manager in all your clusters. And we&rsquo;ll use Octopilot to &ldquo;propagate&rdquo; the certificates to all the clusters, through a gitops workflow, by storing and updating the certificates in one or more git repositories.</p><p>You can setup a nightly CronJob, a scheduled pipeline, or anything else you prefer to regularly call Octopilot, to make sure that all the certificates stored in the git repositories are up-to-date - or to create Pull Requests to update them.</p><p>In fact, we won&rsquo;t call Octopilot directly, we&rsquo;ll call a script that will perform a few operations before executing Octopilot:</p><ul><li>first, we&rsquo;ll need to retrieve all the certificates from the Kubernetes API - using something like <code>kubectl -n cert-manager get certificates.cert-manager.io</code></li><li>then, for each certificate, we&rsquo;ll need to retrieve its associated Kubernetes Secret, which contains the actual certificate and its private key - both base64-encoded - using something like <code>kubectl -n cert-manager get secret $secretName -o go-template='{{index .data "tls.crt"}}' > tls.crt.base64</code></li><li>optionally, we can extract some data from the certificates, such as the DNS names, validity dates, and so on - to generate nice commit messages and Pull requests. Use the <code>openssl</code> tool to extract the <code>startdate</code> and <code>enddate</code> fields for example.</li><li>and then we can execute Octopilot with something like the following:</li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ octopilot <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;owner/prod-env&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yaml(file=</span><span class=si>${</span><span class=nv>APP_NAME</span><span class=si>}</span><span class=s2>-values.yaml,path=tls.certificate)=file(path=tls.crt.base64)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;sops(file=</span><span class=si>${</span><span class=nv>APP_NAME</span><span class=si>}</span><span class=s2>-secrets.yaml,key=tls.certificateKey)=file(path=tls.key.base64)&#34;</span> <span class=se>\
</span><span class=se></span>    --git-commit-title <span class=s2>&#34;Update </span><span class=si>${</span><span class=nv>APP_NAME</span><span class=si>}</span><span class=s2> certificate&#34;</span> <span class=se>\
</span><span class=se></span>    --git-commit-body <span class=s2>&#34;...&#34;</span> <span class=se>\
</span><span class=se></span>    --git-branch-prefix <span class=s2>&#34;octopilot-cert-</span><span class=si>${</span><span class=nv>APP_NAME</span><span class=si>}</span><span class=s2>-&#34;</span> <span class=se>\
</span><span class=se></span>    --pr-labels <span class=s2>&#34;update-cert-</span><span class=si>${</span><span class=nv>APP_NAME</span><span class=si>}</span><span class=s2>&#34;</span>
</code></pre></div><p>Here, we are running 2 <a href=#updaters>updaters</a>:</p><ul><li>the <a href=#yaml>YAML updater</a>, to update the Helm values file of our application, and set the <code>tls.certificate</code> value to the content of a <code>tls.cert.base64</code> file</li><li>the <a href=#sops>SOPS updater</a>, to update the Helm secrets file of our application - which is in fact a <a href=https://github.com/mozilla/sops>sops</a>-encrypted YAML file - and set the <code>tls.certificateKey</code> value to the content of a <code>tls.key.base64</code> file</li></ul><p>We&rsquo;re using the default <code>reset</code> strategy, which means that if we don&rsquo;t merge the PR right away, and your CronJob runs a second time, it will find the existing PR and just reset it from the base branch, and then force push the commit. So you&rsquo;ll always only see 1 commit, rebased every day, with the latest certificate. We&rsquo;re using a specific label for our Pull Request: <code>octopilot-cert-${APP_NAME}</code> - to make sure we&rsquo;ll find any existing PR for our application/certificate, and that each application/certificate will get its own PR.</p><h2 id=result>Result</h2><p>This is a screenshot of a Pull Request on an environment git repository, which updates a specific certificate.</p><p><img src=screenshot-cert-pr.png alt></p><p>You can see that we extracted a few information, to make it easy for reviewers - because the diff is just a base64 blob replaced by another one:</p><ul><li>the creation date of the new certificate - in fact this is the creation timestamp of the latest cert-manager order, which means the latest time the certificate has been renewed</li><li>the new validity dates, extracted using <code>openssl x509 -in tls.crt -noout -startdate</code> for example</li><li>the validity dates of the currently deployed certificate, retrieved using <code>openssl s_client -servername $domain -connect $domain:443 > previous.crt</code> for example, and then extracted using <code>openssl</code> once again</li><li>the list of domains - or DNS names - for which this certificate is valid, extracted using <code>kubectl -n cert-manager get $cert -o go-template={{.spec.dnsNames}}</code> for example</li></ul><p>Merging this Pull Request would result in a re-deployment of our application, with an updated certificate. So with this approach we can control when we want to deploy new certificates.</p></div></section><section id=use-case-go-deps><h1><a href=#use-case-go-deps>Updating Go dependencies</a></h1><div class=content><p>One of the downside of using a micro-services architecture is that it requires a lot of maintenance on the different git repositories. Even more when you have more repositories than teams or developers. For example, you&rsquo;ll need to ensure that:</p><ul><li>the dependencies are up to date</li><li>the &ldquo;config files&rdquo; for your Continuous Delivery pipeline(s) are up to date</li><li>and so on&mldr;</li></ul><p>Automating the creation of Pull Requests to keep your git repositories &ldquo;in sync&rdquo; is a good way to reduce the maintenance effort. <a href=https://dependabot.com/>Dependabot</a> is one way to do it, Octopilot is another. The benefits of using Octopilot are:</p><ul><li>you control where it is executed - in your own infrastructure</li><li>you control exactly what it does - including running your own custom scripts/binaries</li></ul><p>One use-case we have is to update the <a href=https://golang.org/>Go</a> dependencies, by running the following commands:</p><ul><li><code>go get -d -t -u</code></li><li><code>go mod tidy</code></li><li><code>go mod vendor</code></li><li><code>go mod verify</code></li></ul><p>For example you can do it on octopilot&rsquo;s own repository, by running:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>export</span> <span class=nv>GITHUB_TOKEN</span><span class=o>=</span>&lt;your_github_token&gt;
$ octopilot <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;dailymotion-oss/octopilot&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;exec(cmd=go,args=get -d -t -u)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;exec(cmd=go,args=mod tidy)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;exec(cmd=go,args=mod vendor)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;exec(cmd=go,args=mod verify)&#34;</span> <span class=se>\
</span><span class=se></span>    --git-stage-pattern <span class=s2>&#34;vendor&#34;</span> <span class=se>\
</span><span class=se></span>    --git-commit-title <span class=s2>&#34;chore(deps): update Go dependencies&#34;</span>
</code></pre></div><p>You can then run it on a regular basis, such as every week, to update all your dependencies at once. And you can use the <a href=#dynamic>dynamic repositories</a> feature to do it on all your repositories with a specific GitHub topic.</p><h2 id=result>Result</h2><p>This is a screenshot of a Pull Request on a git repository, which updates all the Go modules.</p><p><img src=screenshot-go-deps-pr.png alt></p><p>Using the <a href=#exec>exec updater</a> we can run any command we want, capture its stdout and/or stderr, and use it in the commit message and/or Pull Request description.</p></div></section><section id=use-case-preview><h1><a href=#use-case-preview>Previsualizing changes</a></h1><div class=content><p>If you&rsquo;re working on your workflow with Octopilot, at some point you might want to &ldquo;preview&rdquo; the changes Octopilot will do, without actually creating the Pull Request(s).</p><p>There is an easy way to do that. You&rsquo;ll need to:</p><ul><li>use the <code>--dry-run</code> CLI flag, to ensure that no operation will be performed on the remote git repository: not pushing branches/commits, not creating/updating Pull Requests, &mldr;</li><li>use the <code>--keep-files</code> CLI flag, to ensure that the changes to the local cloned git repositories won&rsquo;t be lost at the end of the process - because by default Octopilot removes all temporary files</li><li>use a verbose log level - such as <code>debug</code> or <code>trace</code> - with the <code>--log-level</code> CLI flag, to retrieve the path of the temporary files created by Octopilot</li></ul><p>For example, if you run:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>export</span> <span class=nv>GITHUB_TOKEN</span><span class=o>=</span>&lt;your_github_token&gt;
$ octopilot <span class=se>\
</span><span class=se></span>    --repo <span class=s2>&#34;dailymotion-oss/octopilot&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yq(file=.goreleaser.yml,expression=&#39;(.dockers[] | select(.dockerfile == \&#34;Dockerfile.goreleaser\&#34;) | .dockerfile) = \&#34;a.new.Dockerfile\&#34;&#39;)&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;yaml(file=.golangci.yml,path=run.timeout)=42m&#34;</span> <span class=se>\
</span><span class=se></span>    --update <span class=s2>&#34;regex(file=README.md,pattern=&#39;(?ms)(.*)&#39;)=replacing the content of the README.md file with this new content&#34;</span> <span class=se>\
</span><span class=se></span>    --dry-run --keep-files --log-level<span class=o>=</span>debug
</code></pre></div><p>Then you should see something like:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>DEBU[0000] Updaters ready                                updaters=&#34;[YQ[file=.goreleaser.yml,expression=(.dockers[] | select(.dockerfile == \&#34;Dockerfile.goreleaser\&#34;) | .dockerfile) = \&#34;a.new.Dockerfile\&#34;,output=,indent=2] YAML[path=run.timeout,file=.golangci.yml,style=,create=false,trim=false,indent=2] Regex[pattern=(?ms)(.*),file=README.md]]&#34;
DEBU[0000] Repositories ready                            repositories=&#34;[{dailymotion-oss octopilot map[]}]&#34;
DEBU[0000] Using &#39;reset&#39; strategy                        repository=dailymotion-oss/octopilot
DEBU[0003] Git repository cloned                         git-reference=HEAD git-url=&#34;https://github.com/dailymotion-oss/octopilot.git&#34; local-path=/var/folders/v0/fx5l3skn17785d8f4l883m6w0000gp/T/octopilot092369223/dailymotion-oss/octopilot
DEBU[0003] No existing Pull Request found                labels=&#34;[octopilot-update]&#34; repository=dailymotion-oss/octopilot
DEBU[0004] Switched Git branch                           branch=octopilot-c3qif432dnc2961tuuh0 repository-name=octopilot
DEBU[0004] Updater finished                              changes=true repository=dailymotion-oss/octopilot updater=&#34;YQ[file=.goreleaser.yml,expression=(.dockers[] | select(.dockerfile == \&#34;Dockerfile.goreleaser\&#34;) | .dockerfile) = \&#34;a.new.Dockerfile\&#34;,output=,indent=2]&#34;
DEBU[0004] Updater finished                              changes=true repository=dailymotion-oss/octopilot updater=&#34;YAML[path=run.timeout,file=.golangci.yml,style=,create=false,trim=false,indent=2]&#34;
DEBU[0004] Updater finished                              changes=true repository=dailymotion-oss/octopilot updater=&#34;Regex[pattern=(?ms)(.*),file=README.md]&#34;
DEBU[0004] All updaters finished                         repository=dailymotion-oss/octopilot
DEBU[0005] Git status                                    repository-name=octopilot status=&#34; M README.md\n M .golangci.yml\n M .goreleaser.yml\n&#34;
DEBU[0006] Git commit                                    commit=d263de874faf26a6ccc8bb2325bc4eb47e0a7029 repository-name=octopilot
WARN[0006] Running in dry-run mode, not pushing changes  repository=dailymotion-oss/octopilot
WARN[0006] Repository update has no changes              repository=dailymotion-oss/octopilot
INFO[0006] Updates finished                              repositories-count=1
</code></pre></div><p>The 2 interesting lines are:</p><ul><li><code>Git repository cloned local-path=/var/folders/v0/fx5l3skn17785d8f4l883m6w0000gp/T/octopilot092369223/dailymotion-oss/octopilot</code></li><li><code>Git commit commit=d263de874faf26a6ccc8bb2325bc4eb47e0a7029</code></li></ul><p>If you go to the directory identified by the <code>local-path</code> value, you can inspect the git repository - for example:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>cd</span> /var/folders/v0/fx5l3skn17785d8f4l883m6w0000gp/T/octopilot092369223/dailymotion-oss/octopilot
$ git show d263de874faf26a6ccc8bb2325bc4eb47e0a7029
</code></pre></div><p>and you should see:</p><div class=highlight><pre class=chroma><code class=language-diff data-lang=diff>commit d263de874faf26a6ccc8bb2325bc4eb47e0a7029 (HEAD -&gt; octopilot-c3qif432dnc2961tuuh0)
Author: author &lt;author@example.com&gt;
Date:   Mon Jul 19 09:19:46 2021 +0200

    Octopilot update

    Updates:

    ### YQ[file=.goreleaser.yml,expression=(.dockers[] | select(.dockerfile == &#34;Dockerfile.goreleaser&#34;) | .dockerfile) = &#34;a.new.Dockerfile&#34;,output=,indent=2]
    Update .goreleaser.yml
    Updating file(s) `.goreleaser.yml` using yq expression `(.dockers[] | select(.dockerfile == &#34;Dockerfile.goreleaser&#34;) | .dockerfile) = &#34;a.new.Dockerfile&#34;`

    ### YAML[path=run.timeout,file=.golangci.yml,style=,create=false,trim=false,indent=2]
    Update .golangci.yml
    Updating path `run.timeout` in file(s) `.golangci.yml`

    ### Regex[pattern=(?ms)(.*),file=README.md]
    Update README.md
    Updating file(s) `README.md` using pattern `(?ms)(.*)`

    --
    Generated by [Octopilot](https://github.com/dailymotion-oss/octopilot) [v0.2.16](https://github.com/dailymotion-oss/octopilot/releases/tag/v0.2.16) from https://github.com/dailymotion-oss/octopilot

<span class=gh>diff --git a/.golangci.yml b/.golangci.yml
</span><span class=gh>index 9a84d2c..b8a04d9 100644
</span><span class=gh></span><span class=gd>--- a/.golangci.yml
</span><span class=gd></span><span class=gi>+++ b/.golangci.yml
</span><span class=gi></span><span class=gu>@@ -1,4 +1,4 @@
</span><span class=gu></span> # See https://golangci-lint.run/usage/configuration/#config-file

 run:
<span class=gd>-  timeout: 3m
</span><span class=gd></span><span class=gi>+  timeout: 42m
</span><span class=gi></span><span class=gh>diff --git a/.goreleaser.yml b/.goreleaser.yml
</span><span class=gh>index 3d8734f..1b96958 100644
</span><span class=gh></span><span class=gd>--- a/.goreleaser.yml
</span><span class=gd></span><span class=gi>+++ b/.goreleaser.yml
</span><span class=gi></span><span class=gu>@@ -12,12 +12,10 @@ builds:
</span><span class=gu></span>       - -X main.buildDate={{.Date}}
     env:
       - CGO_ENABLED=0
<span class=gd>-
</span><span class=gd></span> archives:
   - format: binary
<span class=gd>-
</span><span class=gd></span> dockers:
<span class=gd>-  - dockerfile: Dockerfile.goreleaser
</span><span class=gd></span><span class=gi>+  - dockerfile: a.new.Dockerfile
</span><span class=gi></span>     image_templates:
       - &#34;ghcr.io/dailymotion-oss/{{.ProjectName}}:{{ .Version }}&#34;
       - &#34;ghcr.io/dailymotion-oss/{{.ProjectName}}:{{ .Tag }}&#34;
<span class=gu>@@ -31,6 +29,5 @@ dockers:
</span><span class=gu></span>       - &#34;--label=org.opencontainers.image.revision={{.FullCommit}}&#34;
       - &#34;--label=org.opencontainers.image.version={{.Version}}&#34;
       - &#34;--label=org.opencontainers.image.source={{.GitURL}}&#34;
<span class=gd>-
</span><span class=gd></span> changelog:
   sort: asc
<span class=gh>diff --git a/README.md b/README.md
</span><span class=gh>index a1dbefa..b247a46 100644
</span><span class=gh></span><span class=gd>--- a/README.md
</span><span class=gd></span><span class=gi>+++ b/README.md
</span><span class=gi></span><span class=gu>@@ -1,115 +1 @@
</span><span class=gu></span><span class=gd>-# Octo Pilot
</span><span class=gd>-...
</span><span class=gd></span><span class=gi>+replacing the content of the README.md file with this new content
</span></code></pre></div><p>This is a good way to ensure that you have the right syntax for your <a href=#updaters>updater(s)</a>, and/or that your git commit is what you want.</p></div></section><section id=detecting-errors-in-scripts><h1><a href=#detecting-errors-in-scripts>Detecting errors in scripts</a></h1><div class=content><p>By default Octopilot does not exit with error even when updates fail. Add the <code>--fail-on-error</code> flag so that Octopilot exits with error when updates fail.</p></div></section><section id=handle-maximum-number-of-repositories-in-parallel><h1><a href=#handle-maximum-number-of-repositories-in-parallel>Handle maximum number of repositories in parallel</a></h1><div class=content><p>By default Octopilot handles all repositories in parallel - creating as many goroutines as there are repositories.
Add the <code>--max-concurrent-repos</code> flag so that Octopilot handles them in a batch way to avoid issues such as github rate limiting, or high load on your CI platform.</p></div></section></div></div></div></div></div></div><div class=sub-footer><div class=container><div class=row><div class=col-12><div class=sub-footer-inner><ul><li><a href=https://www.dailymotion.com>Dailymotion</a></li></ul></div></div></div></div></div><script type=text/javascript src=js/scripts.min.eaf147370baecdd07c022597db631f99cab1c9cd6479de586f30327a568d6a0f.js></script></body></html>